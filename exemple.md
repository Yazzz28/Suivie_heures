name: CI - Continuous Integration

on:
push:
branches:
- development
- staging
- production
pull_request:
branches:
- development
- staging
- production

jobs:
# üß™ TESTS UNITAIRES ET D'INT√âGRATION
unit-integration-tests:
runs-on: ubuntu-latest
steps:
- name: üì• R√©cup√©rer le code
uses: actions/checkout@v4

      - name: üîß Installer Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: üì¶ Installer les d√©pendances
        run: npm ci

      - name: üìù V√©rifier la syntaxe (Lint)
        run: npm run lint

      - name: üß™ Lancer les tests unitaires et d'int√©gration
        run: npm run test

      - name: üìä Tests avec couverture
        run: npm run test:coverage

# üéØ TESTS E2E FRONTEND (CYPRESS)
e2e-frontend-tests:
runs-on: ubuntu-latest
needs: unit-integration-tests
strategy:
matrix:
environment: [staging, production]
steps:
- name: üì• R√©cup√©rer le code
uses: actions/checkout@v4

      - name: üîß Installer Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: üì¶ Installer les d√©pendances
        run: npm ci

      - name: üèóÔ∏è Construire l'application pour les tests
        run: npm run build --env=${{ matrix.environment }}

      - name: üöÄ D√©marrer le serveur de test
        run: |
          npm run start-server &
          sleep 10

      - name: üéØ Lancer les tests E2E frontend avec Cypress
        run: npm run e2e:ci --env=${{ matrix.environment }}

# üåê TESTS E2E FULL STACK
e2e-fullstack-tests:
runs-on: ubuntu-latest
needs: unit-integration-tests
strategy:
matrix:
environment: [staging]  # On utilise staging pour les tests full stack
steps:
- name: üì• R√©cup√©rer le code
uses: actions/checkout@v4

      - name: üîß Installer Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: üê≥ Configurer Docker
        uses: docker/setup-buildx-action@v3

      - name: üîÑ R√©cup√©rer l'image Docker du backend
        run: |
          # Pull de l'image backend r√©elle en environnement staging
          echo "üîÑ R√©cup√©ration de l'image backend en environnement ${{ matrix.environment }}"
          
          # Remplacez par votre vraie image backend
          # docker pull your-registry/ambu-connect-backend:${{ matrix.environment }}
          
          # Pour l'instant, simulation avec nginx qui expose une API REST basique
          docker run -d --name backend-test \
            -p 8080:80 \
            --env NODE_ENV=${{ matrix.environment }} \
            nginx:alpine
          
          # Attendre que le backend soit pr√™t
          sleep 10

      - name: üì¶ Installer les d√©pendances frontend
        run: npm ci

      - name: üèóÔ∏è Construire l'application frontend
        run: npm run build --env=${{ matrix.environment }}

      - name: üöÄ D√©marrer le frontend
        run: |
          npm run start-server &
          sleep 10

      - name: üåê Lancer les tests E2E full stack
        run: |
          echo "üß™ Tests E2E complets avec backend en ${{ matrix.environment }}"
          npm run e2e:ci --env=${{ matrix.environment }}

      - name: üßπ Nettoyer les conteneurs
        if: always()
        run: |
          docker stop backend-test || true
          docker rm backend-test || true

# üê≥ CONSTRUIRE LES IMAGES DOCKER
build-docker-images:
runs-on: ubuntu-latest
needs: [unit-integration-tests, e2e-frontend-tests]
if: github.event_name == 'push'
strategy:
matrix:
environment: [development, staging, production]
steps:
- name: üì• R√©cup√©rer le code
uses: actions/checkout@v4

      - name: üê≥ Configurer Docker
        uses: docker/setup-buildx-action@v3

      - name: üèóÔ∏è Construire l'image Docker
        run: |
          docker build -f Dockerfile.${{ matrix.environment }} \
            -t ambu-connect:${{ matrix.environment }} .

      - name: üíæ Sauvegarder l'image
        run: |
          docker save ambu-connect:${{ matrix.environment }} > ambu-connect-${{ matrix.environment }}.tar

      - name: üì§ Partager l'image
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-${{ matrix.environment }}
          path: ambu-connect-${{ matrix.environment }}.tar
          retention-days: 1

# ‚úÖ VALIDATION FINALE
ci-success:
runs-on: ubuntu-latest
needs: [unit-integration-tests, e2e-frontend-tests, e2e-fullstack-tests, build-docker-images]
if: always()
steps:
- name: ‚úÖ V√©rifier le statut du CI
run: |
if [[ "${{ needs.unit-integration-tests.result }}" == "success" && \
"${{ needs.e2e-frontend-tests.result }}" == "success" && \
"${{ needs.e2e-fullstack-tests.result }}" == "success" && \
"${{ needs.build-docker-images.result }}" == "success" ]]; then
echo "üéâ CI r√©ussi ! Toutes les √©tapes sont pass√©es avec succ√®s."
echo "‚úÖ Tests unitaires/int√©gration : OK"
echo "‚úÖ Tests E2E frontend : OK"
echo "‚úÖ Tests E2E full stack : OK"
echo "‚úÖ Construction des images Docker : OK"
else
echo "‚ùå CI √©chou√©. V√©rifiez les logs des √©tapes pr√©c√©dentes."
exit 1
fi

name: CD - Continuous Deployment

on:
push:
branches:
- staging
- production

jobs:
build-and-push:
name: üõ†Ô∏è Build & Push Docker image
runs-on: ubuntu-latest

    outputs:
      tag: ${{ steps.set_tag.outputs.tag }}

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîê Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}

      - name: üè∑Ô∏è Set Docker image tag
        id: set_tag
        run: |
          if [[ "${GITHUB_REF##*/}" == "production" ]]; then
            echo "tag=production" >> "$GITHUB_OUTPUT"
          else
            echo "tag=staging" >> "$GITHUB_OUTPUT"
          fi

      - name: üîß Set Dockerfile based on environment
        id: set_dockerfile
        run: |
          TAG=${{ steps.set_tag.outputs.tag }}
          echo "dockerfile=Dockerfile.$TAG" >> "$GITHUB_OUTPUT"

      - name: üõ†Ô∏è Build and Push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ steps.set_dockerfile.outputs.dockerfile }}
          push: true
          tags: |
            ${{ secrets.DOCKER_HUB_USERNAME }}/ambu-connect:${{ steps.set_tag.outputs.tag }}
            ${{ secrets.DOCKER_HUB_USERNAME }}/ambu-connect:${{ steps.set_tag.outputs.tag }}-${{ github.sha }}

deploy:
name: üöÄ Deploy to VPS
needs: build-and-push
runs-on: ubuntu-latest

    steps:
      - name: üîë Set up SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_PRIVATE_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519

      - name: üöÄ SSH to VPS and deploy
        run: |
          TAG=${{ needs.build-and-push.outputs.tag }}
          VPS_USER="${{ secrets.VPS_USER }}"
          VPS_HOST="${{ secrets.VPS_HOST }}"
          SSH_KEY="~/.ssh/id_ed25519"
          
          if [[ "$TAG" == "production" ]]; then
            VPS_PATH="~/ambuConnect/ambuConnect_prod/frontend"
            PORT="4202"
          else
            VPS_PATH="~/ambuConnect/ambuConnect_staging/frontend"
            PORT="4201"
          fi

          ssh -o StrictHostKeyChecking=no -i $SSH_KEY $VPS_USER@$VPS_HOST << EOF
            echo "üöÄ D√©ploiement de ambu-connect en environnement $TAG"
            
            # Cr√©er les r√©pertoires si n√©cessaire
            mkdir -p $VPS_PATH/logs
            mkdir -p $VPS_PATH/config
            
            # Se d√©placer dans le r√©pertoire de d√©ploiement
            cd $VPS_PATH
            
            # Arr√™ter et supprimer le conteneur existant
            echo "üîÑ Arr√™t du conteneur existant..."
            docker stop ambu-connect-$TAG || true
            docker rm ambu-connect-$TAG || true
            
            # Nettoyer les anciennes images
            echo "üßπ Nettoyage des anciennes images..."
            docker image prune -f
            
            # R√©cup√©rer la nouvelle image
            echo "üì¶ R√©cup√©ration de l'image Docker..."
            docker pull ${{ secrets.DOCKER_HUB_USERNAME }}/ambu-connect:$TAG
            
            # D√©marrer le nouveau conteneur
            echo "üöÄ D√©marrage du nouveau conteneur..."
            docker run -d \
              --name ambu-connect-$TAG \
              --restart unless-stopped \
              -p $PORT:80 \
              -v $VPS_PATH/logs:/var/log/nginx \
              -v $VPS_PATH/config:/etc/nginx/conf.d \
              ${{ secrets.DOCKER_HUB_USERNAME }}/ambu-connect:$TAG
            
            # V√©rifier que le conteneur est d√©marr√©
            echo "üîç V√©rification du conteneur..."
            sleep 5
            docker ps | grep ambu-connect-$TAG
            
            echo "‚úÖ D√©ploiement termin√© pour l'environnement $TAG"
            echo "üåê Application disponible sur le port $PORT"
          EOF

      - name: üè• Health check
        run: |
          TAG=${{ needs.build-and-push.outputs.tag }}
          VPS_HOST="${{ secrets.VPS_HOST }}"
          
          if [[ "$TAG" == "production" ]]; then
            PORT="4202"
          else
            PORT="4201"
          fi
          
          echo "üîç V√©rification de sant√© de l'application..."
          sleep 10
          
          # Tentative de connexion √† l'application
          if curl -f -s --max-time 30 http://$VPS_HOST:$PORT/ > /dev/null; then
            echo "‚úÖ Application accessible et fonctionnelle"
          else
            echo "‚ö†Ô∏è Application potentiellement indisponible, v√©rifiez manuellement"
            echo "üåê URL: http://$VPS_HOST:$PORT/"
          fi

deployment-notification:
name: üì¢ Notification de d√©ploiement
needs: [build-and-push, deploy]
runs-on: ubuntu-latest
if: always()

    steps:
      - name: üìã G√©n√©rer le rapport de d√©ploiement
        run: |
          TAG=${{ needs.build-and-push.outputs.tag }}
          
          echo "üìä RAPPORT DE D√âPLOIEMENT AMBU-CONNECT"
          echo "======================================"
          echo "üïê Date: $(date)"
          echo "üåø Branche: ${{ github.ref_name }}"
          echo "üè∑Ô∏è Tag: $TAG"
          echo "üìù Commit: ${{ github.sha }}"
          echo "üë§ Auteur: ${{ github.actor }}"
          echo "üê≥ Image: ${{ secrets.DOCKER_HUB_USERNAME }}/ambu-connect:$TAG"
          echo ""
          
          if [[ "${{ needs.build-and-push.result }}" == "success" && "${{ needs.deploy.result }}" == "success" ]]; then
            echo "‚úÖ D√©ploiement r√©ussi"
            echo "üåê Application disponible en environnement $TAG"
            if [[ "$TAG" == "production" ]]; then
              echo "üéØ URL Production: http://${{ secrets.VPS_HOST }}:4202/"
            else
              echo "üéØ URL Staging: http://${{ secrets.VPS_HOST }}:4201/"
            fi
          else
            echo "‚ùå D√©ploiement √©chou√©"
            echo "üîç Build: ${{ needs.build-and-push.result }}"
            echo "üîç Deploy: ${{ needs.deploy.result }}"
            echo "üìù V√©rifiez les logs des √©tapes pr√©c√©dentes"
          fi


cree un fichier ci et un fichier cd dans le dossier .github/workflows inspirer de ce code
si il le faut modifie aussi dockerfile et docker-compose
